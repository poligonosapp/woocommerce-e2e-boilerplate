"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Internal dependencies
 */
const {
  merchant,
  withRestApi,
  clickFilter,
  moveAllItemsToTrash
} = require('@woocommerce/e2e-utils');

const statusColumnTextSelector = 'mark.order-status > span'; // Define order statuses to filter against

const orderStatus = [['Pending payment', 'wc-pending'], ['Processing', 'wc-processing'], ['On hold', 'wc-on-hold'], ['Completed', 'wc-completed'], ['Cancelled', 'wc-cancelled'], ['Refunded', 'wc-refunded'], ['Failed', 'wc-failed']];
const defaultOrder = {
  payment_method: 'cod',
  billing: {
    first_name: 'John',
    last_name: 'Doe',
    email: 'john.doe@example.com'
  }
};

const runOrderStatusFiltersTest = () => {
  describe('WooCommerce Orders > Filter Orders by Status', () => {
    beforeAll(async () => {
      // First, let's create some orders we can filter against
      const orders = orderStatus.map(entryPair => {
        const statusName = entryPair[1].replace('wc-', '');
        return _objectSpread(_objectSpread({}, defaultOrder), {}, {
          status: statusName
        });
      }); // Create the orders using the API

      await withRestApi.batchCreateOrders(orders, false); // Next, let's login and navigate to the Orders page

      await merchant.login();
      await merchant.openAllOrdersView();
    });
    afterAll(async () => {
      // Make sure we're on the all orders view and cleanup the orders we created
      await merchant.openAllOrdersView();
      await moveAllItemsToTrash();
    });
    it.each(orderStatus)('should filter by %s', async (statusText, statusClassName) => {
      // Identify which statuses should be shown or hidden
      const shownStatus = {
        text: statusText
      };
      const hiddenStatuses = orderStatus.filter(pair => !pair.includes(statusText)).map(_ref => {
        let [statusText] = _ref;
        return {
          text: statusText
        };
      }); // Click the status filter and verify that only the matching order is shown

      await clickFilter('.' + statusClassName);
      await expect(page).toMatchElement(statusColumnTextSelector, shownStatus); // Verify other statuses don't show

      for (const hiddenStatus of hiddenStatuses) {
        await expect(page).not.toMatchElement(statusColumnTextSelector, hiddenStatus);
      }
    });
    it('should filter by All', async () => {
      // Make sure all the order statuses that were created show in this list
      await clickFilter('.all');

      for (const [statusText] of orderStatus) {
        await expect(page).toMatchElement(statusColumnTextSelector, {
          text: statusText
        });
      }
    });
  });
};

module.exports = runOrderStatusFiltersTest;
//# sourceMappingURL=wp-admin-order-status-filters.test.js.map